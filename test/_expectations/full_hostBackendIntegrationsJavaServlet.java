/**
* This file was automatically generated by OMG (OpenMicrofrontends Generator).
* DO NOT MODIFY!
*/

package org.openmicrofrontends.demo;

import java.io.IOException;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.URI;
import java.time.Duration;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletConfig;
import jakarta.servlet.ServletContext;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.http.HttpHost;
import org.mitre.dsmiley.httpproxy.ProxyServlet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class OpenMicrofrontendHostIntegrations {

    private static final Logger logger = LoggerFactory.getLogger(OpenMicrofrontendHostIntegrations.class);
    private static final ObjectMapper objectMapper = new ObjectMapper();

    private static final String OM_BASE_PATH = "/__open_microfrontends__";
    private static final String OM_ASSETS_SUB_PATH = "/assets";
    private static final String OM_PROXIES_SUB_PATH = "/proxies";
    private static final String OM_SETUP_SUB_PATH = "/setup";

    public record User(String username, String displayName) {
    }

    private static String toFullUrl(String... parts) {
        if (parts == null || parts.length == 0) {
            return "";
        }

        var result = new StringBuilder();
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part == null || part.isBlank() || (i > 0 && part.equals("/"))) {
                continue;
            }
            if (part.startsWith("/")) {
                part = part.substring(1);
            }
            if (part.endsWith("/")) {
                part = part.substring(0, part.length() - 1);
            }
            if (!result.isEmpty()) {
                result.append("/");
            }
            result.append(part);
        }

        return result.toString();
    }

    
        
public static class MyFirstMicrofrontendHostIntegrationFilter implements Filter {

    public interface MicrofrontendBaseSetup {
        String getMicrofrontendBaseUrl();
        default int getMicrofrontendRequestTimeoutSec() {
            return 5;
        }
        default int getMicrofrontendAssetsAndProxyTimeout() {
            return 60;
        }
        default User getUser(HttpServletRequest req) {
            return null;
        }
        default String getLang(HttpServletRequest req) {
            return null;
        }
        default Map<String, String> getHostContext() {
            return null;
        }
        
            
                
                
                    /*
                    *  Security Headers for a request to the API Proxy proxy1.
                    *  Schemes: [{"ApiKeyAuth":[]}]
                    */
                    Map<String, String> getApiProxyRequestProxy1GetSecurityHeaders(HttpServletRequest req);
                
            
                
                    /*
                    *  Target URL of the API Proxy proxy2
                    */
                    String getApiProxyProxy2Url();
                
                
            
        
        
            
            
                /*
                *  Security Headers for a user permissions request to the Microfrontend
                *  Schemes: [{"ApiKeyAuth":[]}]
                */
                Map<String, String> getUserPermissionsRequestSecurityHeaders(HttpServletRequest req);
            
        
        
            /*
            * Add build manifest to a cache (should not be cached more than 5min)
            */
            void buildTimestampOrVersionCachePut(String tsOrVersion);
            /*
            * Get the build manifest from a cache
            */
            String buildTimestampOrVersionCacheGet();
        
        
            /*
            * Add the user permissions for the current user to a cache
            */
            default void userPermissionsCachePut(String key, Map<String, Boolean> userPermissions) {
            }
            /*
            * Get the user permissions for the current user from a cache
            */
            default Map<String, Boolean> userPermissionsCacheGet(String key) {
                return null;
            }
         
    }


    private static final String ATTR_EXTRA_HEADERS = MyFirstMicrofrontendHostIntegrationFilter.class + ".extraHeaders";

    private final MicrofrontendBaseSetup baseSetup;
    private final HttpClient httpClient;
    private final InternalProxyServlet proxyServlet;

    public MyFirstMicrofrontendHostIntegrationFilter(MicrofrontendBaseSetup baseSetup) {
        this.baseSetup = baseSetup;
        this.httpClient = HttpClient.newBuilder()
                .version(HttpClient.Version.HTTP_1_1)
                .connectTimeout(Duration.ofSeconds(baseSetup.getMicrofrontendRequestTimeoutSec()))
                .build();
        this.proxyServlet = new InternalProxyServlet();
    }

    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
        var httpReq = (HttpServletRequest) req;
        var httpRes = (HttpServletResponse) res;

        var url = httpReq.getRequestURI();
        if (!url.startsWith(OM_BASE_PATH + "/MyFirstMicrofrontend")) {
            chain.doFilter(req, res);
            return;
        }

        url = url.replace(OM_BASE_PATH + "/MyFirstMicrofrontend", "");
        logger.debug("[OpenMicrofrontends] Processing request for Microfrontend MyFirstMicrofrontend: {}", url);

        if (httpReq.getMethod().equals("GET") && url.equals(OM_SETUP_SUB_PATH)) {
            try {
                var setup = getSetup(httpReq);
                res.setContentType("application/json");
                res.getWriter().write(objectMapper.writeValueAsString(setup));
                return;
            } catch (Exception e) {
                logger.error("[OpenMicrofrontends] Error while processing config request for Microfrontend MyFirstMicrofrontend", e);
                if (!httpRes.isCommitted()) {
                    httpRes.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                }
            }
        }

        if (httpReq.getMethod().equals("GET") && url.startsWith(OM_ASSETS_SUB_PATH)) {
            var targetAssetPath = toFullUrl(baseSetup.getMicrofrontendBaseUrl(), "/", url.substring(OM_ASSETS_SUB_PATH.length()));
            try {
                proxyServlet.proxy(httpReq, httpRes, targetAssetPath, null);
                return;
            } catch (Exception e) {
                logger.error("[OpenMicrofrontends] Error while fetching asset " + targetAssetPath + " for Microfrontend MyFirstMicrofrontend", e);
                if (!httpRes.isCommitted()) {
                    httpRes.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                }
                return;
            }
        }

        
            if (url.startsWith(OM_PROXIES_SUB_PATH)) {
                var proxyUrl = url.substring(OM_PROXIES_SUB_PATH.length());
                
                    if (proxyUrl.startsWith("/proxy1")) {
                        proxyUrl = proxyUrl.substring("/proxy1".length());
                                                    var securityHeaders = baseSetup.getApiProxyRequestProxy1GetSecurityHeaders(httpReq);
                                                                            var proxyTargetPath = toFullUrl(baseSetup.getMicrofrontendBaseUrl(), "/api", proxyUrl);
                        
                        try {
                            proxyServlet.proxy(httpReq, httpRes, proxyTargetPath, securityHeaders);
                            return;
                        } catch (Exception e) {
                            logger.error("[OpenMicrofrontends] Error while forwarding call to proxy 'proxy1' for Microfrontend MyFirstMicrofrontend. Target:" + httpReq.getMethod() + " " + proxyTargetPath, e);
                            if (!httpRes.isCommitted()) {
                                httpRes.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                            }
                            return;
                        }
                    }
                
                    if (proxyUrl.startsWith("/proxy2")) {
                        proxyUrl = proxyUrl.substring("/proxy2".length());
                                                    Map<String, String> securityHeaders = null;
                                                                            var proxyTargetPath = toFullUrl(baseSetup.getApiProxyProxy2Url(), proxyUrl);
                        
                        try {
                            proxyServlet.proxy(httpReq, httpRes, proxyTargetPath, securityHeaders);
                            return;
                        } catch (Exception e) {
                            logger.error("[OpenMicrofrontends] Error while forwarding call to proxy 'proxy2' for Microfrontend MyFirstMicrofrontend. Target:" + httpReq.getMethod() + " " + proxyTargetPath, e);
                            if (!httpRes.isCommitted()) {
                                httpRes.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                            }
                            return;
                        }
                    }
                
            }
        

        chain.doFilter(req, res);
    }

    private String fetchWithExtraHeaders(String url, String baseUrl, Map<String, String> headers) throws IOException, InterruptedException {
        var fullUrl = toFullUrl(baseUrl, url);
        var requestBuilder = HttpRequest.newBuilder()
            .uri(URI.create(fullUrl))
            .GET();

        headers.forEach(requestBuilder::header);

        return httpClient.send(requestBuilder.build(), HttpResponse.BodyHandlers.ofString()).body();
    }

    @SuppressWarnings("unchecked")
    private Map<String, Boolean> getPermissions(HttpServletRequest req, String username) throws IOException, InterruptedException {
                    
                String cacheKey = null;
                if (username != null) {
                    cacheKey = "__om_user_permissions__" + username;
                    var permissionsFromCache = baseSetup.userPermissionsCacheGet(cacheKey);
                    if (permissionsFromCache != null) {
                        return permissionsFromCache;
                    }
                }

                
                    var extraHeaders = baseSetup.getUserPermissionsRequestSecurityHeaders(req);
                
                var res = fetchWithExtraHeaders("/permissions", baseSetup.getMicrofrontendBaseUrl(), extraHeaders);
                var permissions = (Map<String, Boolean>) objectMapper.readValue(res, Map.class);

                if (cacheKey != null) {
                    baseSetup.userPermissionsCachePut(cacheKey, permissions);
                }

                return permissions;
            
        
    }

    private String getBuildTimestampOrVersion() throws IOException, InterruptedException {
        
            var buildTimestampOrVersionFromCache = baseSetup.buildTimestampOrVersionCacheGet();
            if (buildTimestampOrVersionFromCache != null) {
                return buildTimestampOrVersionFromCache;
            }
            var res = fetchWithExtraHeaders("/build.yaml", baseSetup.getMicrofrontendBaseUrl(), Map.of());
            var manifest = objectMapper.readValue(res, Map.class);

            String buildTimestampOrVersion = (String) manifest.get("timestamp");
            if (buildTimestampOrVersion == null) {
                buildTimestampOrVersion = (String) manifest.get("version");
            }
            if (buildTimestampOrVersion == null) {
                logger.warn("[OpenMicrofrontends] No build timestamp or version found in build manifest: {}", manifest);
            } else {
                baseSetup.buildTimestampOrVersionCachePut(buildTimestampOrVersion);
            }
            return buildTimestampOrVersion;
        
    }

    private Map<String, Object> getSetup(HttpServletRequest req) throws Exception {
        var user = baseSetup.getUser(req);
        var setup = new HashMap<String, Object>();
        setup.put("user", user);
        setup.put("lang", baseSetup.getLang(req));
        setup.put("permissions", getPermissions(req, user != null ? user.username : null));
        setup.put("assetBuildTimestampOrVersion", getBuildTimestampOrVersion());
        setup.put("hostContext", baseSetup.getHostContext());
        return setup;
    }

    private class InternalProxyServlet extends ProxyServlet {

        InternalProxyServlet() {
            var initParams = Map.of(
                    "http.socket.timeout", "3000",
                    "http.read.timeout", "" + baseSetup.getMicrofrontendAssetsAndProxyTimeout() * 1000,
                    "targetUri", "http://localhost:8080/dummy"
            );
            var config = new ServletConfig() {
                @Override
                public String getServletName() {
                    return "InternalProxyServlet";
                }
                @Override
                public ServletContext getServletContext() {
                    return null;
                }
                @Override
                public String getInitParameter(String name) {
                    return initParams.get(name);
                }
                @Override
                public Enumeration<String> getInitParameterNames() {
                    return null;
                }
            };
            try {
                this.init(config);
            } catch (ServletException e) {
                throw new RuntimeException(e);
            }
        }

        void proxy(HttpServletRequest req, HttpServletResponse res, String targetURL, Map<String, String> extraHeaders) throws IOException {
            var pathIdx = targetURL.indexOf("/", 10);
            var host = pathIdx != -1 ? targetURL.substring(0, pathIdx) : targetURL;
            req.setAttribute(ATTR_TARGET_URI, targetURL);
            req.setAttribute(ATTR_TARGET_HOST, HttpHost.create(host));
            req.setAttribute(ATTR_EXTRA_HEADERS, extraHeaders);
            this.service(req, res);
        }

        @Override
        protected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException {
            try {
                super.service(req, resp);
            } catch (Exception e) {
                logger.error("[OpenMicrofrontends] Error during proxying for Microfrontend MyFirstMicrofrontend. Request URL: {}", req.getRequestURL(), e);
                if (!resp.isCommitted()) {
                    resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Proxying failed");
                }
            }
        }

        @Override
        protected String rewriteUrlFromRequest(HttpServletRequest req) {
            // We ignore the incoming path
            return (String) req.getAttribute(ATTR_TARGET_URI);
        }

        @Override
        @SuppressWarnings("unchecked")
        protected void copyRequestHeaders(HttpServletRequest servletRequest, org.apache.http.HttpRequest proxyRequest) {
            super.copyRequestHeaders(servletRequest, proxyRequest);
            // Add extra headers
            var extraHeaders = (Map<String, String>) servletRequest.getAttribute(ATTR_EXTRA_HEADERS);
            if (extraHeaders != null) {
                extraHeaders.forEach(proxyRequest::addHeader);
            }
        }
    }
}

    
}
