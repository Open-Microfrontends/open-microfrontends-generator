/**
 * This file was automatically generated by OMG (OpenMicrofrontends Generator).
 * DO NOT MODIFY!
 */

import { createProxyServer } from 'http-proxy-3';
import type { ServerResponse, IncomingMessage } from 'node:http';
import type { OpenMicrofrontendsClientContext } from '@open-microfrontends/types/OpenMicrofrontendsRendererFunction';

import type { OpenMicrofrontendsServerContext } from '@open-microfrontends/types/OpenMicrofrontendsServerSideRendererFunction';

interface Logger {
  debug(msg: string, ...args: any[]): void;
  info(msg: string, ...args: any[]): void;
  warn(msg: string, ...args: any[]): void;
  error(msg: string, ...args: any[]): void;
}

type ImportMap = {
  imports: Record<string, string>;
};

const DEFAULT_MICROFRONTEND_REQUEST_TIMEOUT_SEC = 5;
const DEFAULT_API_PROXY_TIMEOUT_SEC = 60;
const DEFAULT_SSR_TIMEOUT_SEC = 5;

function toFullUrl(...parts: Array<string>): string {
  return parts
    .filter((part, idx) => part && part.trim() && (idx === 0 || part !== '/'))
    .map((part) => (part.endsWith('/') ? part.slice(0, -1) : part))
    .map((part, idx) => (idx > 0 && part.startsWith('/') ? part.substring(1) : part))
    .join('/');
}

/* TypeScript type from Schemas */

export interface Microfrontend1Config {
  customerId: string;
}

export interface Microfrontend1TopicPing {
  ping: true;
  [k: string]: unknown;
}

/*
 * The setup calculated by the Host Application backend
 */
type HostBackendMicrofrontendSetup = Pick<
  OpenMicrofrontendsClientContext<any, any, any, any, any>,
  'lang' | 'user' | 'permissions' | 'hostContext'
> & {
  readonly assetBuildTimestampOrVersion?: string;
  readonly rewrittenImportMaps?: {
    readonly imports: Record<string, string>;
  };
};

const omBasePath = '/__open_microfrontends__';
const omAssetsSubPath = '/assets';
const omProxiesSubPath = '/proxies';
const omSetupSubPath = '/setup';

const getWithTimeoutAndExtraHeaders = async (
  url: string,
  baseUrl: string | null,
  timeoutSec: number,
  headers: Record<string, string>
): Promise<Response> => {
  const fullUrl = toFullUrl(baseUrl, url);
  return await fetch(fullUrl, {
    method: 'GET',
    headers: {
      ...headers,
    },
    signal: AbortSignal.timeout(timeoutSec * 1000),
  });
};

const postWithTimeoutAndExtraHeaders = async (
  url: string,
  baseUrl: string | null,
  body: object,
  timeoutSec: number,
  headers: Record<string, string>
): Promise<Response> => {
  const fullUrl = toFullUrl(baseUrl, url);
  return await fetch(fullUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...headers,
    },
    body: JSON.stringify(body),
    signal: AbortSignal.timeout(timeoutSec * 1000),
  });
};

/* Type Parameters */

export type Microfrontend1Permissions = {
  readonly showDetails: boolean;

  readonly deletePermitted: boolean;
};

export interface MyFirstMicrofrontendBaseSetup {
  microfrontendBaseUrl: string;
  microfrontendRequestTimeoutSec?: number;
  getUser(req: IncomingMessage): Promise<HostBackendMicrofrontendSetup['user'] | null>;
  getLang?(req: IncomingMessage): Promise<string | null>;
  getHostContext?: HostBackendMicrofrontendSetup['hostContext'];
  rewriteImportMaps?(importMaps: ImportMap): ImportMap;

  apiProxyTimeoutSec?: number;

  /*
   *  Security Headers for a request to the API Proxy proxy1.
   *  Schemes: [{"ApiKeyAuth":[]}]
   */
  apiProxyRequestProxy1GetSecurityHeaders(req: IncomingMessage): Promise<Record<string, string>>;

  /*
   *  Target URL of the API Proxy proxy2
   */
  apiProxyProxy2Url: string;

  /*
   *  Security Headers for a user permissions request to the Microfrontend
   *  Schemes: [{"ApiKeyAuth":[]}]
   */
  userPermissionsRequestGetSecurityHeaders(req: IncomingMessage): Promise<Record<string, string>>;

  microfrontendSSRTimeoutSec?: number;

  /*
   *  Security Headers for an SSR request to the Microfrontend
   *  Schemes: [{"ApiKeyAuth":[]}]
   */
  ssrGetSecurityHeaders(req: IncomingMessage): Promise<Record<string, string>>;

  /*
   * Add build manifest to a cache (should not be cached more than 5min)
   */
  buildTimestampOrVersionCachePut(tsOrVersion: string): Promise<void>;
  /*
   * Get the build manifest from a cache
   */
  buildTimestampOrVersionCacheGet(): Promise<string | null>;

  /*
   * Add the user permissions for the current user to a cache
   */
  userPermissionsCachePut?(key: string, userPermissions: object): Promise<void>;
  /*
   * Get the user permissions for the current user from a cache
   */
  userPermissionsCacheGet?(key: string): Promise<object | null>;

  /*
   * Add the SSR result to a cache
   * IMPORTANT: It might be necessary to add the user's name/id to the cache key if the render result depends on the authenticated user!
   */
  ssrCachePut?(key: string, userName: string | undefined, result: object): Promise<void>;
  /*
   * Get the SSR result from a cache
   */
  ssrCacheGet?(key: string, userName: string | undefined): Promise<object | null>;

  /*
   *  Custom logger
   */
  logger?: Logger;
}

const getMyFirstMicrofrontendPermissions = async (
  req: IncomingMessage,
  username: string | undefined,
  baseSetup: MyFirstMicrofrontendBaseSetup
): Promise<HostBackendMicrofrontendSetup['permissions']> => {
  let cacheKey;
  if (username) {
    cacheKey = `__om_user_permissions__${username}`;
    var permissionsFromCache = await baseSetup.userPermissionsCacheGet?.(cacheKey);
    if (permissionsFromCache) {
      return permissionsFromCache;
    }
  }

  const extraHeaders = await baseSetup.userPermissionsRequestGetSecurityHeaders(req);

  const res = await getWithTimeoutAndExtraHeaders(
    '/permissions',
    baseSetup.microfrontendBaseUrl,
    baseSetup.microfrontendRequestTimeoutSec ?? DEFAULT_MICROFRONTEND_REQUEST_TIMEOUT_SEC,
    extraHeaders
  );
  if (!res.ok) {
    throw new Error(`[OpenMicrofrontends] Error while requesting permissions from /permissions: ${res.statusText}`);
  }
  const permissions = await res.json();

  if (cacheKey) {
    await baseSetup.userPermissionsCachePut?.(cacheKey, permissions);
  }

  return permissions;
};

const getMyFirstMicrofrontendBuildTimestampOrVersion = async (
  baseSetup: MyFirstMicrofrontendBaseSetup,
  logger: Logger
): Promise<string | undefined> => {
  const buildTimestampOrVersionFromCache = await baseSetup.buildTimestampOrVersionCacheGet();
  if (buildTimestampOrVersionFromCache) {
    return buildTimestampOrVersionFromCache;
  }
  const res = await getWithTimeoutAndExtraHeaders(
    '/build.yaml',
    baseSetup.microfrontendBaseUrl,
    baseSetup.microfrontendRequestTimeoutSec ?? DEFAULT_MICROFRONTEND_REQUEST_TIMEOUT_SEC,
    {}
  );
  if (!res.ok) {
    logger.warn(`[OpenMicrofrontends] Error while fetching build manifest from /build.yaml: ${res.statusText}`);
    return undefined;
  }
  const buildManifest = await res.json();
  const buildTimestampOrVersion = buildManifest.timestamp || buildManifest.version;
  if (!buildTimestampOrVersion) {
    logger.warn('[OpenMicrofrontends] No build timestamp or version found in build manifest:', buildManifest);
  } else {
    await baseSetup.buildTimestampOrVersionCachePut(buildTimestampOrVersion);
  }
  return buildTimestampOrVersion;
};

const getMyFirstMicrofrontendSetup = async (
  req: IncomingMessage,
  baseSetup: MyFirstMicrofrontendBaseSetup,
  logger: Logger
): Promise<HostBackendMicrofrontendSetup> => {
  const user = await baseSetup.getUser(req);
  return {
    lang: await baseSetup.getLang?.(req),
    user,
    permissions: await getMyFirstMicrofrontendPermissions(req, user?.username, baseSetup),
    assetBuildTimestampOrVersion: await getMyFirstMicrofrontendBuildTimestampOrVersion(baseSetup, logger),
    hostContext: baseSetup.getHostContext,
  };
};

export const myFirstMicrofrontendHostIntegrationMiddleware = (baseSetup: MyFirstMicrofrontendBaseSetup) => {
  const logger = baseSetup.logger || console;
  const proxy = createProxyServer({
    changeOrigin: true,
    ignorePath: true,
    followRedirects: false,
  });
  proxy.on('error', (err, req, res) => {
    logger.error(`[OpenMicrofrontends] Proxy error for Microfrontend MyFirstMicrofrontend`, err);
    (res as ServerResponse).statusCode = 500;
    res.end();
  });

  return async (req: IncomingMessage, res: ServerResponse, next: (err?: any) => void) => {
    // Required by the SSR render function
    (req as any)['__om_base_setup_MyFirstMicrofrontend__'] = baseSetup;

    let url = req.url;
    if (!url.startsWith(`${omBasePath}/MyFirstMicrofrontend`)) {
      next();
      return;
    }

    url = url.replace(`${omBasePath}/MyFirstMicrofrontend`, '');
    logger.debug('[OpenMicrofrontends] Processing request for Microfrontend MyFirstMicrofrontend:', url);

    if (req.method === 'GET' && url === omSetupSubPath) {
      try {
        const config = await getMyFirstMicrofrontendSetup(req, baseSetup, logger);
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify(config));
        return;
      } catch (e) {
        logger.error(
          '[OpenMicrofrontends] Error while processing config request for Microfrontend MyFirstMicrofrontend',
          e
        );
        res.statusCode = 500;
        res.end();
        return;
      }
    }

    if (req.method === 'GET' && url.startsWith(omAssetsSubPath)) {
      const targetAssetPath = toFullUrl(baseSetup.microfrontendBaseUrl, '/', url.replace(omAssetsSubPath, ''));
      try {
        proxy.web(req, res, {
          target: targetAssetPath,
          timeout: (baseSetup.microfrontendRequestTimeoutSec ?? DEFAULT_MICROFRONTEND_REQUEST_TIMEOUT_SEC) * 1000,
        });
        return;
      } catch (e) {
        logger.error(
          `[OpenMicrofrontends] Error while fetching asset ${targetAssetPath} for Microfrontend MyFirstMicrofrontend`,
          e
        );
        res.statusCode = 500;
        res.end();
        return;
      }
    }

    if (url.startsWith(omProxiesSubPath)) {
      let proxyUrl = url.replace(omProxiesSubPath, '');

      if (proxyUrl.startsWith('/proxy1')) {
        proxyUrl = proxyUrl.replace('/proxy1', '');
        const securityHeaders = await baseSetup.apiProxyRequestProxy1GetSecurityHeaders(req);
        const proxyTargetPath = toFullUrl(baseSetup.microfrontendBaseUrl, '/api', proxyUrl);

        try {
          proxy.web(req, res, {
            target: proxyTargetPath,
            headers: securityHeaders,
            timeout: (baseSetup.apiProxyTimeoutSec ?? DEFAULT_API_PROXY_TIMEOUT_SEC) * 1000,
          });
          return;
        } catch (e) {
          logger.error(
            `[OpenMicrofrontends] Error while forwarding call to proxy 'proxy1' for Microfrontend MyFirstMicrofrontend. Target: ${req.method} ${proxyTargetPath}`,
            e
          );
          res.statusCode = 500;
          res.end();
          return;
        }
      }

      if (proxyUrl.startsWith('/proxy2')) {
        proxyUrl = proxyUrl.replace('/proxy2', '');
        const securityHeaders = {};
        const proxyTargetPath = toFullUrl(baseSetup.apiProxyProxy2Url, proxyUrl);

        try {
          proxy.web(req, res, {
            target: proxyTargetPath,
            headers: securityHeaders,
            timeout: (baseSetup.apiProxyTimeoutSec ?? DEFAULT_API_PROXY_TIMEOUT_SEC) * 1000,
          });
          return;
        } catch (e) {
          logger.error(
            `[OpenMicrofrontends] Error while forwarding call to proxy 'proxy2' for Microfrontend MyFirstMicrofrontend. Target: ${req.method} ${proxyTargetPath}`,
            e
          );
          res.statusCode = 500;
          res.end();
          return;
        }
      }
    }

    next();
  };
};

type SSRContext = OpenMicrofrontendsServerContext<Partial<Microfrontend1Config>, Microfrontend1Permissions>;
type SSRResponse = {
  readonly contentHtml: string;
  readonly headHtml: string;
};

export const myFirstMicrofrontendServerSideRender = async (
  req: IncomingMessage,
  context: SSRContext
): Promise<SSRResponse> => {
  const baseSetup = (req as any)['__om_base_setup_MyFirstMicrofrontend__'] as MyFirstMicrofrontendBaseSetup | undefined;
  if (!baseSetup) {
    throw new Error('[OpenMicrofrontends] Not setup found. Did you forget to register the generated middleware?');
  }

  const logger = baseSetup.logger || console;
  const defaultConfig = {
    customerId: '1000',
  };
  const contextWithDefaultConfig = {
    ...context,
    config: {
      ...defaultConfig,
      ...context.config,
    },
  };

  const securityHeaders = await baseSetup.ssrGetSecurityHeaders(req);

  const response = await postWithTimeoutAndExtraHeaders(
    '/ssr',
    baseSetup.microfrontendBaseUrl,
    contextWithDefaultConfig,
    baseSetup.microfrontendSSRTimeoutSec ?? DEFAULT_SSR_TIMEOUT_SEC,
    securityHeaders
  );
  if (!response.ok) {
    throw new Error(`[OpenMicrofrontends] SSR request failed with status ${response.status}`);
  }

  const { html, injectHeadScript } = await response.json();

  const assetsPath = `${omBasePath}/MyFirstMicrofrontend${omAssetsSubPath}`;
  const fallbackAssetTimestamp = Math.floor(Date.now() / 10000) * 10;
  const assetBuildTimestampOrVersion = await getMyFirstMicrofrontendBuildTimestampOrVersion(baseSetup, logger);

  const headHtml = `
            
                <!-- Add stylesheets to the head, so the pre-rendered HTML is already styled -->
                
                    <link href="${assetsPath}/styles.css?v=${assetBuildTimestampOrVersion ?? fallbackAssetTimestamp}" rel="stylesheet" />
                
            
            <script>window['__om_ssr_MyFirstMicrofrontend_${context.id}__'] = true;</script>
            ${injectHeadScript ? `<script>${injectHeadScript}</script>` : ''}
        `;

  return {
    contentHtml: html,
    headHtml,
  };
};
