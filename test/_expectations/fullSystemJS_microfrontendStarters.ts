/**
 * This file was automatically generated by OMG (OpenMicrofrontends Generator).
 * DO NOT MODIFY!
 */

import type { OpenMicrofrontendsClientContext } from '@open-microfrontends/types/OpenMicrofrontendsRendererFunction';

/* TypeScript type from Schemas */

export interface Microfrontend1Config {
  customerId: string;
}

export interface Microfrontend1TopicPing {
  ping: true;
  [k: string]: unknown;
}

// Helper

function toFullUrl(...parts: Array<string>): string {
  return parts
    .filter((part, idx) => part && part.trim() && (idx === 0 || part !== '/'))
    .map((part) => (part.endsWith('/') ? part.slice(0, -1) : part))
    .map((part, idx) => (idx > 0 && part.startsWith('/') ? part.substring(1) : part))
    .join('/');
}

function addCssLinkTag(url: string, addedElements: Array<HTMLElement>): void {
  const linkElem = document.createElement('link');
  linkElem.rel = 'stylesheet';
  linkElem.href = url;
  linkElem.addEventListener('error', (error) => {
    console.error('[OpenMicrofrontends] Error loading CSS resource: ', url, error);
  });
  document.head.appendChild(linkElem);
  addedElements.push(linkElem);
}

declare var System: any;

function installSystemJSImportMap(initialModules: Array<string>, importMap: any) {
  if (!importMap.imports) {
    return;
  }
  const currentImportMap = System.getImportMap();
  const newImportMap = { imports: {}, scopes: {} };
  for (const _import in importMap.imports) {
    if (!currentImportMap.imports[_import]) {
      newImportMap.imports[_import] = importMap.imports[_import];
    } else if (currentImportMap.imports[_import] !== importMap.imports[_import]) {
      // Conflicting import map entries
      initialModules.forEach((moduleUrl) => {
        if (!(moduleUrl in newImportMap.scopes)) {
          newImportMap.scopes[moduleUrl] = {};
        }
        newImportMap.scopes[moduleUrl][_import] = importMap.imports[_import];
        // Also make sure conflicting entries only load modules from "their" import map
        newImportMap.scopes[importMap.imports[_import]] = {
          ...importMap.imports,
        };
      });
    }
  }
  System.addImportMap(newImportMap);
}

/*
 * The setup calculated by the Host Application backend
 */
type HostBackendMicrofrontendSetup = Pick<
  OpenMicrofrontendsClientContext<any, any, any, any, any>,
  'lang' | 'user' | 'permissions' | 'hostContext'
> & {
  readonly assetBuildTimestampOrVersion?: string;
  readonly rewrittenImportMaps?: {
    readonly imports: Record<string, string>;
  };
};

const omBasePath = '/__open_microfrontends__';
const omAssetsSubPath = '/assets';
const omProxiesSubPath = '/proxies';
const omSetupSubPath = '/setup';

const fallbackAssetTimestamp = Math.floor(Date.now() / 10000) * 10;

/* Type Parameters */

type Microfrontend1MessagesPublish = Record<string, any>;
type Microfrontend1MessagesSubscribe = Record<string, any>;

/* Type-safe MessageBus slice for the client */

type Microfrontend1ClientMessageBus = {
  publish(topic: 'ping', data: Microfrontend1TopicPing): void;

  subscribe(topic: 'ping', cb: (data: Microfrontend1TopicPing) => void): void;
  unsubscribe(topic: 'ping', cb: (data: Microfrontend1TopicPing) => void): void;
};

/* Default config  */

const defaultConfig = {
  customerId: '1000',
};

/* Render function type with aligned config and message bus */

type Microfrontend1ClientContext = Omit<
  OpenMicrofrontendsClientContext<
    Partial<Microfrontend1Config>,
    undefined,
    undefined,
    Microfrontend1MessagesPublish,
    Microfrontend1MessagesSubscribe
  >,
  'apiProxyPaths' | 'permissions' | 'user'
>;

/* Microfrontend setup */

const getHostBackendMicrofrontendSetup = async (id: string, name: string): Promise<HostBackendMicrofrontendSetup> => {
  const preloadedSetup = window[`__om__setup__${name}_${id}`];
  if (preloadedSetup) {
    return preloadedSetup;
  }
  try {
    const response = await fetch(`${omBasePath}/${name}${omSetupSubPath}`);
    return await response.json();
  } catch (e) {
    console.error(
      `[OpenMicrofrontends] Loading setup of Microfrontend ${name} failed. Did you add the necessary Host Integration?`,
      e
    );
    throw new Error(`[OpenMicrofrontends] Loading setup of Microfrontend ${name} failed!`);
  }
};

/* Start function */

export async function startMyFirstMicrofrontend(hostElement: HTMLElement, context: Microfrontend1ClientContext) {
  const addedElements: Array<HTMLElement> = [];
  const exportedModules: Array<any> = [];
  const assetsPath = `${omBasePath}/MyFirstMicrofrontend${omAssetsSubPath}`;
  const proxiesPath = `${omBasePath}/MyFirstMicrofrontend${omProxiesSubPath}`;
  const setup = await getHostBackendMicrofrontendSetup(context.id, 'MyFirstMicrofrontend');
  const { assetBuildTimestampOrVersion, rewrittenImportMaps, ...serverContext } = setup;
  const serverSideRendered = !!window[`__om_ssr_MyFirstMicrofrontend_${context.id}__`];

  if (serverSideRendered) {
    console.info('[OpenMicrofrontends] Found server-side rendered Microfrontend "My First Microfrontend"');
  }

  if (!serverSideRendered) {
    // Add stylesheets

    addCssLinkTag(
      toFullUrl(assetsPath, `styles.css?v=${assetBuildTimestampOrVersion ?? fallbackAssetTimestamp}`),
      addedElements
    );
  }

  const jsUrls = [
    toFullUrl(assetsPath, `Microfrontend.js?v=${assetBuildTimestampOrVersion ?? fallbackAssetTimestamp}`),
  ];

  // Load initial modules consecutively (SystemJS)
  if (typeof System === 'undefined') {
    throw new Error(
      '[OpenMicrofrontends] Microfrontend "My First Microfrontend" requires SystemJS but is not available!'
    );
  }

  const initialModuleMapping = {};
  jsUrls.forEach((jsUrl) => {
    const moduleWithoutQuery = jsUrl.split('?')[0];
    initialModuleMapping[moduleWithoutQuery] = jsUrl;
  });
  const finalImportMap = {
    imports: {
      ...initialModuleMapping,
      ...(rewrittenImportMaps?.imports ?? {
        module1: 'http://localhost:12345/module1.js',
        module2: 'http://localhost:12345/module2.js',
      }),
    },
  };
  installSystemJSImportMap(jsUrls, finalImportMap);

  try {
    for (const jsUrl of jsUrls) {
      const module = await System.import(jsUrl);
      if (module) {
        exportedModules.push(module);
      }
    }
  } catch (e) {
    throw new Error('[OpenMicrofrontends] Loading assets of Microfrontend "My First Microfrontend" failed!');
  }

  const renderFunction =
    exportedModules.find((m) => 'startMyFirstMicrofrontend' in m)?.['startMyFirstMicrofrontend'] ||
    exportedModules.find((m) => 'default' in m && 'startMyFirstMicrofrontend' in m.default)?.default?.[
      'startMyFirstMicrofrontend'
    ] ||
    (window as any)['startMyFirstMicrofrontend'];
  if (!renderFunction) {
    throw new Error('[OpenMicrofrontends] Render function of Microfrontend "My First Microfrontend" not found!');
  }

  const apiProxyPaths = {};

  apiProxyPaths['proxy1'] = `${proxiesPath}/proxy1`;

  apiProxyPaths['proxy2'] = `${proxiesPath}/proxy2`;

  const contextWithDefaultConfig = {
    ...serverContext,
    ...context,
    apiProxyPaths,
    serverSideRendered,
    config: {
      ...defaultConfig,
      ...context.config,
    },
  };

  // Render the Microfrontend
  console.info('[OpenMicrofrontends] Starting Microfrontend "My First Microfrontend"');
  const lifecycleHooks = await renderFunction(hostElement, contextWithDefaultConfig);

  return {
    close: async () => {
      console.info('[OpenMicrofrontends] Closing Microfrontend "My First Microfrontend"');
      await lifecycleHooks?.onRemove();
      addedElements.forEach((elem) => elem.remove());
      hostElement.innerHTML = '';
    },

    messages: context.messageBus as Microfrontend1ClientMessageBus,
  };
}
