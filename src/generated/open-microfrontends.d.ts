/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type HttpUrl = string;
export type I18NString =
  | string
  | {
      /**
       * This interface was referenced by `undefined`'s JSON-Schema definition
       * via the `patternProperty` "^[a-z]{2}$".
       */
      [k: string]: string;
    };
export type Security = SecurityRequirement[];
export type RelativeJsPath = string;
export type RelativeCssPath = string;
export type HttpOrWebSocketUrlOrRelativePath = string;
export type CoreAndValidationSpecificationsMetaSchema = CoreVocabularyMetaSchema &
  ApplicatorVocabularyMetaSchema &
  UnevaluatedApplicatorVocabularyMetaSchema &
  ValidationVocabularyMetaSchema &
  MetaDataVocabularyMetaSchema &
  FormatVocabularyMetaSchemaForAnnotationResults &
  ContentVocabularyMetaSchema & {
    /**
     * @deprecated
     */
    definitions?: {
      [k: string]: {
        [k: string]: any;
      };
    };
    /**
     * @deprecated
     */
    dependencies?: {
      [k: string]:
        | {
            [k: string]: any;
          }
        | string[];
    };
    /**
     * @deprecated
     */
    $recursiveAnchor?: string;
    /**
     * @deprecated
     */
    $recursiveRef?: string;
    [k: string]: any;
  } & (
    | {
        /**
         * @deprecated
         */
        definitions?: {
          [k: string]: {
            [k: string]: any;
          };
        };
        /**
         * @deprecated
         */
        dependencies?: {
          [k: string]:
            | {
                [k: string]: any;
              }
            | string[];
        };
        /**
         * @deprecated
         */
        $recursiveAnchor?: string;
        /**
         * @deprecated
         */
        $recursiveRef?: string;
        [k: string]: any;
      }
    | boolean
  );
export type CoreVocabularyMetaSchema = {
  $id?: string;
  $schema?: string;
  $ref?: string;
  $anchor?: string;
  $dynamicRef?: string;
  $dynamicAnchor?: string;
  $vocabulary?: {
    [k: string]: boolean;
  };
  $comment?: string;
  $defs?: {
    [k: string]: {
      [k: string]: any;
    };
  };
  [k: string]: any;
} & (
  | {
      $id?: string;
      $schema?: string;
      $ref?: string;
      $anchor?: string;
      $dynamicRef?: string;
      $dynamicAnchor?: string;
      $vocabulary?: {
        [k: string]: boolean;
      };
      $comment?: string;
      $defs?: {
        [k: string]: {
          [k: string]: any;
        };
      };
      [k: string]: any;
    }
  | boolean
);
export type ApplicatorVocabularyMetaSchema = {
  /**
   * @minItems 1
   */
  prefixItems?: [
    {
      [k: string]: any;
    },
    ...{
      [k: string]: any;
    }[]
  ];
  items?: {
    [k: string]: any;
  };
  contains?: {
    [k: string]: any;
  };
  additionalProperties?: {
    [k: string]: any;
  };
  properties?: {
    [k: string]: {
      [k: string]: any;
    };
  };
  patternProperties?: {
    [k: string]: {
      [k: string]: any;
    };
  };
  dependentSchemas?: {
    [k: string]: {
      [k: string]: any;
    };
  };
  propertyNames?: {
    [k: string]: any;
  };
  if?: {
    [k: string]: any;
  };
  then?: {
    [k: string]: any;
  };
  else?: {
    [k: string]: any;
  };
  /**
   * @minItems 1
   */
  allOf?: [
    {
      [k: string]: any;
    },
    ...{
      [k: string]: any;
    }[]
  ];
  /**
   * @minItems 1
   */
  anyOf?: [
    {
      [k: string]: any;
    },
    ...{
      [k: string]: any;
    }[]
  ];
  /**
   * @minItems 1
   */
  oneOf?: [
    {
      [k: string]: any;
    },
    ...{
      [k: string]: any;
    }[]
  ];
  not?: {
    [k: string]: any;
  };
  [k: string]: any;
} & (
  | {
      /**
       * @minItems 1
       */
      prefixItems?: [
        {
          [k: string]: any;
        },
        ...{
          [k: string]: any;
        }[]
      ];
      items?: {
        [k: string]: any;
      };
      contains?: {
        [k: string]: any;
      };
      additionalProperties?: {
        [k: string]: any;
      };
      properties?: {
        [k: string]: {
          [k: string]: any;
        };
      };
      patternProperties?: {
        [k: string]: {
          [k: string]: any;
        };
      };
      dependentSchemas?: {
        [k: string]: {
          [k: string]: any;
        };
      };
      propertyNames?: {
        [k: string]: any;
      };
      if?: {
        [k: string]: any;
      };
      then?: {
        [k: string]: any;
      };
      else?: {
        [k: string]: any;
      };
      /**
       * @minItems 1
       */
      allOf?: [
        {
          [k: string]: any;
        },
        ...{
          [k: string]: any;
        }[]
      ];
      /**
       * @minItems 1
       */
      anyOf?: [
        {
          [k: string]: any;
        },
        ...{
          [k: string]: any;
        }[]
      ];
      /**
       * @minItems 1
       */
      oneOf?: [
        {
          [k: string]: any;
        },
        ...{
          [k: string]: any;
        }[]
      ];
      not?: {
        [k: string]: any;
      };
      [k: string]: any;
    }
  | boolean
);
export type UnevaluatedApplicatorVocabularyMetaSchema = {
  unevaluatedItems?: {
    [k: string]: any;
  };
  unevaluatedProperties?: {
    [k: string]: any;
  };
  [k: string]: any;
} & (
  | {
      unevaluatedItems?: {
        [k: string]: any;
      };
      unevaluatedProperties?: {
        [k: string]: any;
      };
      [k: string]: any;
    }
  | boolean
);
export type ValidationVocabularyMetaSchema = {
  type?:
    | ("array" | "boolean" | "integer" | "null" | "number" | "object" | "string")
    | [
        "array" | "boolean" | "integer" | "null" | "number" | "object" | "string",
        ...("array" | "boolean" | "integer" | "null" | "number" | "object" | "string")[]
      ];
  const?: any;
  enum?: any[];
  multipleOf?: number;
  maximum?: number;
  exclusiveMaximum?: number;
  minimum?: number;
  exclusiveMinimum?: number;
  maxLength?: number;
  minLength?: number;
  pattern?: string;
  maxItems?: number;
  minItems?: number;
  uniqueItems?: boolean;
  maxContains?: number;
  minContains?: number;
  maxProperties?: number;
  minProperties?: number;
  required?: string[];
  dependentRequired?: {
    [k: string]: string[];
  };
  [k: string]: any;
} & (
  | {
      type?:
        | ("array" | "boolean" | "integer" | "null" | "number" | "object" | "string")
        | [
            "array" | "boolean" | "integer" | "null" | "number" | "object" | "string",
            ...("array" | "boolean" | "integer" | "null" | "number" | "object" | "string")[]
          ];
      const?: any;
      enum?: any[];
      multipleOf?: number;
      maximum?: number;
      exclusiveMaximum?: number;
      minimum?: number;
      exclusiveMinimum?: number;
      maxLength?: number;
      minLength?: number;
      pattern?: string;
      maxItems?: number;
      minItems?: number;
      uniqueItems?: boolean;
      maxContains?: number;
      minContains?: number;
      maxProperties?: number;
      minProperties?: number;
      required?: string[];
      dependentRequired?: {
        [k: string]: string[];
      };
      [k: string]: any;
    }
  | boolean
);
export type MetaDataVocabularyMetaSchema = {
  title?: string;
  description?: string;
  default?: any;
  deprecated?: boolean;
  readOnly?: boolean;
  writeOnly?: boolean;
  examples?: any[];
  [k: string]: any;
} & (
  | {
      title?: string;
      description?: string;
      default?: any;
      deprecated?: boolean;
      readOnly?: boolean;
      writeOnly?: boolean;
      examples?: any[];
      [k: string]: any;
    }
  | boolean
);
export type FormatVocabularyMetaSchemaForAnnotationResults = {
  format?: string;
  [k: string]: any;
} & (
  | {
      format?: string;
      [k: string]: any;
    }
  | boolean
);
export type ContentVocabularyMetaSchema = {
  contentEncoding?: string;
  contentMediaType?: string;
  contentSchema?: {
    [k: string]: any;
  };
  [k: string]: any;
} & (
  | {
      contentEncoding?: string;
      contentMediaType?: string;
      contentSchema?: {
        [k: string]: any;
      };
      [k: string]: any;
    }
  | boolean
);

export interface HttpsOpenMicrofrontendsSchemas100 {
  $schema?: string;
  /**
   * Section for defining re-usable security schemes for API proxies
   */
  securitySchemes?: {
    [k: string]: {
      [k: string]: any;
    };
  };
  openMicrofrontends: string;
  servers?: Server[];
  microfrontends: Microfrontend[];
}
export interface Server {
  url: HttpUrl;
  description?: string;
}
export interface Microfrontend {
  name: string;
  title?: I18NString;
  description?: string;
  security?: Security;
  resources: Resources;
  paths: Paths;
  /**
   * Defines all user-permissions used within this microfrontend
   */
  frontendPermissions?: string[];
  /**
   * The name of the function that can be used in the browser to launch this microfrontend
   */
  globalLaunchFunction: string;
  apiProxies?: APIProxy;
  config?: Config;
  messages?: Messages;
  annotations?: Annotations;
}
export interface SecurityRequirement {
  [k: string]: string[];
}
export interface Resources {
  /**
   * A list of JS resources required to start the Microservice
   */
  js: RelativeJsPath[];
  /**
   * A list of CSS resources that should be loaded
   */
  css?: RelativeCssPath[];
}
export interface Paths {
  /**
   * The base path for the required resources
   */
  resourcesBase: string;
  /**
   * The path to generate the initial HTML for Hybrid Rendering
   */
  ssrHtml?: string;
}
/**
 * Defines private API endpoints the framework needs to provide relative paths for
 */
export interface APIProxy {
  /**
   * This interface was referenced by `APIProxy`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z_][a-zA-Z0-9_]+$".
   */
  [k: string]: HttpOrWebSocketUrlOrRelativePath | APIProxyConfig;
}
export interface APIProxyConfig {
  url: HttpOrWebSocketUrlOrRelativePath;
  security?: Security;
  [k: string]: any;
}
export interface Config {
  schema: CoreAndValidationSpecificationsMetaSchema;
  default: {
    [k: string]: any;
  };
}
export interface Messages {
  [k: string]: Message;
}
/**
 * This interface was referenced by `Messages`'s JSON-Schema definition
 * via the `patternProperty` "^.+$".
 */
export interface Message {
  /**
   * The Microfrontend publish this message type
   */
  publish?: boolean;
  /**
   * The Microfrontend subscribes this message type
   */
  subscribe?: boolean;
  schema?: CoreAndValidationSpecificationsMetaSchema;
}
/**
 * Some annotations for the framework(s) consuming this spec
 */
export interface Annotations {
  [k: string]: any;
}
