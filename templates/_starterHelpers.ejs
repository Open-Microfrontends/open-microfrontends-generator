
// Helper

<% if (spec.microfrontends.find(m => !m.assets.js.moduleSystem || m.assets.js.moduleSystem === 'none')) { %>
function addJsScriptTag(url: string, addedElements: Array<HTMLElement>): Promise<void> {
    return new Promise((resolve, reject) => {
        const scriptElem = document.createElement('script');
        scriptElem.src = url;
        scriptElem.addEventListener('error', (error) => {
            console.error('[OpenMicrofrontends] Error loading JS resource: ', url, error);
            reject(error);
        });
        scriptElem.addEventListener('load', () => {
            resolve();
        });
        document.head.appendChild(scriptElem);
        addedElements.push(scriptElem);
    });
}
<% } %>

function addCssLinkTag(url: string, addedElements: Array<HTMLElement>): void {
    const linkElem = document.createElement('link');
    linkElem.rel = 'stylesheet';
    linkElem.href = url;
    linkElem.addEventListener('error', (error) => {
        console.error('[OpenMicrofrontends] Error loading CSS resource: ', url, error);
    });
    document.head.appendChild(linkElem);
    addedElements.push(linkElem);
}

function toFullUrl(...parts: Array<string>): string {
    return parts
        .map((part) => part.endsWith('/') ? part.slice(0, -1) : part)
        .map((part, idx) => idx > 0 && part && !part.startsWith('/') ? `/${part}` : part)
        .join('');
}

<% if (spec.microfrontends.find(m => m.assets.js.moduleSystem === 'SystemJS')) { %>
declare var System: any;

function installSystemJSImportMap(initialModules: Array<string>, importMap: any) {
    if (!importMap.imports) {
        return;
    }
    const currentImportMap = System.getImportMap();
    const newImportMap = { imports: {}, scopes: {} };
    for (const _import in importMap.imports) {
        if (!currentImportMap.imports[_import]) {
            newImportMap.imports[_import] = importMap.imports[_import];
        } else if (currentImportMap.imports[_import] !== importMap.imports[_import]) {
            // Conflicting import map entries
            initialModules.forEach((moduleUrl) => {
                if (!(moduleUrl in newImportMap.scopes)) {
                    newImportMap.scopes[moduleUrl] = {};
                }
                newImportMap.scopes[moduleUrl][_import] = importMap.imports[_import];
                // Also make sure conflicting entries only load modules from "their" import map
                newImportMap.scopes[importMap.imports[_import]] = {
                    ...importMap.imports,
                }
            });
        }
    }
    System.addImportMap(newImportMap);
}
<% } %>
